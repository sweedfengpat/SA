// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/patza/app/ent/bank"
	"github.com/patza/app/ent/bill"
	"github.com/patza/app/ent/confirmation"
	"github.com/patza/app/ent/user"

	"github.com/facebookincubator/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBank         = "Bank"
	TypeBill         = "Bill"
	TypeConfirmation = "Confirmation"
	TypeUser         = "User"
)

// BankMutation represents an operation that mutate the Banks
// nodes in the graph.
type BankMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_Bank         *string
	clearedFields map[string]struct{}
	bill          map[int]struct{}
	removedbill   map[int]struct{}
	done          bool
	oldValue      func(context.Context) (*Bank, error)
}

var _ ent.Mutation = (*BankMutation)(nil)

// bankOption allows to manage the mutation configuration using functional options.
type bankOption func(*BankMutation)

// newBankMutation creates new mutation for $n.Name.
func newBankMutation(c config, op Op, opts ...bankOption) *BankMutation {
	m := &BankMutation{
		config:        c,
		op:            op,
		typ:           TypeBank,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBankID sets the id field of the mutation.
func withBankID(id int) bankOption {
	return func(m *BankMutation) {
		var (
			err   error
			once  sync.Once
			value *Bank
		)
		m.oldValue = func(ctx context.Context) (*Bank, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Bank.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBank sets the old Bank of the mutation.
func withBank(node *Bank) bankOption {
	return func(m *BankMutation) {
		m.oldValue = func(context.Context) (*Bank, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BankMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BankMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *BankMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetBank sets the Bank field.
func (m *BankMutation) SetBank(s string) {
	m._Bank = &s
}

// Bank returns the Bank value in the mutation.
func (m *BankMutation) Bank() (r string, exists bool) {
	v := m._Bank
	if v == nil {
		return
	}
	return *v, true
}

// OldBank returns the old Bank value of the Bank.
// If the Bank object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BankMutation) OldBank(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBank is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBank requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBank: %w", err)
	}
	return oldValue.Bank, nil
}

// ResetBank reset all changes of the "Bank" field.
func (m *BankMutation) ResetBank() {
	m._Bank = nil
}

// AddBillIDs adds the bill edge to Bill by ids.
func (m *BankMutation) AddBillIDs(ids ...int) {
	if m.bill == nil {
		m.bill = make(map[int]struct{})
	}
	for i := range ids {
		m.bill[ids[i]] = struct{}{}
	}
}

// RemoveBillIDs removes the bill edge to Bill by ids.
func (m *BankMutation) RemoveBillIDs(ids ...int) {
	if m.removedbill == nil {
		m.removedbill = make(map[int]struct{})
	}
	for i := range ids {
		m.removedbill[ids[i]] = struct{}{}
	}
}

// RemovedBill returns the removed ids of bill.
func (m *BankMutation) RemovedBillIDs() (ids []int) {
	for id := range m.removedbill {
		ids = append(ids, id)
	}
	return
}

// BillIDs returns the bill ids in the mutation.
func (m *BankMutation) BillIDs() (ids []int) {
	for id := range m.bill {
		ids = append(ids, id)
	}
	return
}

// ResetBill reset all changes of the "bill" edge.
func (m *BankMutation) ResetBill() {
	m.bill = nil
	m.removedbill = nil
}

// Op returns the operation name.
func (m *BankMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Bank).
func (m *BankMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *BankMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Bank != nil {
		fields = append(fields, bank.FieldBank)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *BankMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bank.FieldBank:
		return m.Bank()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *BankMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bank.FieldBank:
		return m.OldBank(ctx)
	}
	return nil, fmt.Errorf("unknown Bank field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BankMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bank.FieldBank:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBank(v)
		return nil
	}
	return fmt.Errorf("unknown Bank field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *BankMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *BankMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BankMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Bank numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *BankMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *BankMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *BankMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Bank nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *BankMutation) ResetField(name string) error {
	switch name {
	case bank.FieldBank:
		m.ResetBank()
		return nil
	}
	return fmt.Errorf("unknown Bank field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *BankMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.bill != nil {
		edges = append(edges, bank.EdgeBill)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *BankMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case bank.EdgeBill:
		ids := make([]ent.Value, 0, len(m.bill))
		for id := range m.bill {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *BankMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedbill != nil {
		edges = append(edges, bank.EdgeBill)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *BankMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case bank.EdgeBill:
		ids := make([]ent.Value, 0, len(m.removedbill))
		for id := range m.removedbill {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *BankMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *BankMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *BankMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Bank unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *BankMutation) ResetEdge(name string) error {
	switch name {
	case bank.EdgeBill:
		m.ResetBill()
		return nil
	}
	return fmt.Errorf("unknown Bank edge %s", name)
}

// BillMutation represents an operation that mutate the Bills
// nodes in the graph.
type BillMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	_Pay_number         *int
	add_Pay_number      *int
	_Pay_total          *int
	add_Pay_total       *int
	_Pay_time           *time.Time
	clearedFields       map[string]struct{}
	bank                *int
	clearedbank         bool
	confirmation        *int
	clearedconfirmation bool
	owner               *int
	clearedowner        bool
	done                bool
	oldValue            func(context.Context) (*Bill, error)
}

var _ ent.Mutation = (*BillMutation)(nil)

// billOption allows to manage the mutation configuration using functional options.
type billOption func(*BillMutation)

// newBillMutation creates new mutation for $n.Name.
func newBillMutation(c config, op Op, opts ...billOption) *BillMutation {
	m := &BillMutation{
		config:        c,
		op:            op,
		typ:           TypeBill,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBillID sets the id field of the mutation.
func withBillID(id int) billOption {
	return func(m *BillMutation) {
		var (
			err   error
			once  sync.Once
			value *Bill
		)
		m.oldValue = func(ctx context.Context) (*Bill, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Bill.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBill sets the old Bill of the mutation.
func withBill(node *Bill) billOption {
	return func(m *BillMutation) {
		m.oldValue = func(context.Context) (*Bill, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BillMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BillMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *BillMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPayNumber sets the Pay_number field.
func (m *BillMutation) SetPayNumber(i int) {
	m._Pay_number = &i
	m.add_Pay_number = nil
}

// PayNumber returns the Pay_number value in the mutation.
func (m *BillMutation) PayNumber() (r int, exists bool) {
	v := m._Pay_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPayNumber returns the old Pay_number value of the Bill.
// If the Bill object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BillMutation) OldPayNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPayNumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPayNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayNumber: %w", err)
	}
	return oldValue.PayNumber, nil
}

// AddPayNumber adds i to Pay_number.
func (m *BillMutation) AddPayNumber(i int) {
	if m.add_Pay_number != nil {
		*m.add_Pay_number += i
	} else {
		m.add_Pay_number = &i
	}
}

// AddedPayNumber returns the value that was added to the Pay_number field in this mutation.
func (m *BillMutation) AddedPayNumber() (r int, exists bool) {
	v := m.add_Pay_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetPayNumber reset all changes of the "Pay_number" field.
func (m *BillMutation) ResetPayNumber() {
	m._Pay_number = nil
	m.add_Pay_number = nil
}

// SetPayTotal sets the Pay_total field.
func (m *BillMutation) SetPayTotal(i int) {
	m._Pay_total = &i
	m.add_Pay_total = nil
}

// PayTotal returns the Pay_total value in the mutation.
func (m *BillMutation) PayTotal() (r int, exists bool) {
	v := m._Pay_total
	if v == nil {
		return
	}
	return *v, true
}

// OldPayTotal returns the old Pay_total value of the Bill.
// If the Bill object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BillMutation) OldPayTotal(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPayTotal is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPayTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayTotal: %w", err)
	}
	return oldValue.PayTotal, nil
}

// AddPayTotal adds i to Pay_total.
func (m *BillMutation) AddPayTotal(i int) {
	if m.add_Pay_total != nil {
		*m.add_Pay_total += i
	} else {
		m.add_Pay_total = &i
	}
}

// AddedPayTotal returns the value that was added to the Pay_total field in this mutation.
func (m *BillMutation) AddedPayTotal() (r int, exists bool) {
	v := m.add_Pay_total
	if v == nil {
		return
	}
	return *v, true
}

// ResetPayTotal reset all changes of the "Pay_total" field.
func (m *BillMutation) ResetPayTotal() {
	m._Pay_total = nil
	m.add_Pay_total = nil
}

// SetPayTime sets the Pay_time field.
func (m *BillMutation) SetPayTime(t time.Time) {
	m._Pay_time = &t
}

// PayTime returns the Pay_time value in the mutation.
func (m *BillMutation) PayTime() (r time.Time, exists bool) {
	v := m._Pay_time
	if v == nil {
		return
	}
	return *v, true
}

// OldPayTime returns the old Pay_time value of the Bill.
// If the Bill object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BillMutation) OldPayTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPayTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPayTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayTime: %w", err)
	}
	return oldValue.PayTime, nil
}

// ResetPayTime reset all changes of the "Pay_time" field.
func (m *BillMutation) ResetPayTime() {
	m._Pay_time = nil
}

// SetBankID sets the bank edge to Bank by id.
func (m *BillMutation) SetBankID(id int) {
	m.bank = &id
}

// ClearBank clears the bank edge to Bank.
func (m *BillMutation) ClearBank() {
	m.clearedbank = true
}

// BankCleared returns if the edge bank was cleared.
func (m *BillMutation) BankCleared() bool {
	return m.clearedbank
}

// BankID returns the bank id in the mutation.
func (m *BillMutation) BankID() (id int, exists bool) {
	if m.bank != nil {
		return *m.bank, true
	}
	return
}

// BankIDs returns the bank ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// BankID instead. It exists only for internal usage by the builders.
func (m *BillMutation) BankIDs() (ids []int) {
	if id := m.bank; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBank reset all changes of the "bank" edge.
func (m *BillMutation) ResetBank() {
	m.bank = nil
	m.clearedbank = false
}

// SetConfirmationID sets the confirmation edge to Confirmation by id.
func (m *BillMutation) SetConfirmationID(id int) {
	m.confirmation = &id
}

// ClearConfirmation clears the confirmation edge to Confirmation.
func (m *BillMutation) ClearConfirmation() {
	m.clearedconfirmation = true
}

// ConfirmationCleared returns if the edge confirmation was cleared.
func (m *BillMutation) ConfirmationCleared() bool {
	return m.clearedconfirmation
}

// ConfirmationID returns the confirmation id in the mutation.
func (m *BillMutation) ConfirmationID() (id int, exists bool) {
	if m.confirmation != nil {
		return *m.confirmation, true
	}
	return
}

// ConfirmationIDs returns the confirmation ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ConfirmationID instead. It exists only for internal usage by the builders.
func (m *BillMutation) ConfirmationIDs() (ids []int) {
	if id := m.confirmation; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConfirmation reset all changes of the "confirmation" edge.
func (m *BillMutation) ResetConfirmation() {
	m.confirmation = nil
	m.clearedconfirmation = false
}

// SetOwnerID sets the owner edge to User by id.
func (m *BillMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the owner edge to User.
func (m *BillMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared returns if the edge owner was cleared.
func (m *BillMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the owner id in the mutation.
func (m *BillMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the owner ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *BillMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner reset all changes of the "owner" edge.
func (m *BillMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Op returns the operation name.
func (m *BillMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Bill).
func (m *BillMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *BillMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m._Pay_number != nil {
		fields = append(fields, bill.FieldPayNumber)
	}
	if m._Pay_total != nil {
		fields = append(fields, bill.FieldPayTotal)
	}
	if m._Pay_time != nil {
		fields = append(fields, bill.FieldPayTime)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *BillMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bill.FieldPayNumber:
		return m.PayNumber()
	case bill.FieldPayTotal:
		return m.PayTotal()
	case bill.FieldPayTime:
		return m.PayTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *BillMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bill.FieldPayNumber:
		return m.OldPayNumber(ctx)
	case bill.FieldPayTotal:
		return m.OldPayTotal(ctx)
	case bill.FieldPayTime:
		return m.OldPayTime(ctx)
	}
	return nil, fmt.Errorf("unknown Bill field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BillMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bill.FieldPayNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayNumber(v)
		return nil
	case bill.FieldPayTotal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayTotal(v)
		return nil
	case bill.FieldPayTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayTime(v)
		return nil
	}
	return fmt.Errorf("unknown Bill field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *BillMutation) AddedFields() []string {
	var fields []string
	if m.add_Pay_number != nil {
		fields = append(fields, bill.FieldPayNumber)
	}
	if m.add_Pay_total != nil {
		fields = append(fields, bill.FieldPayTotal)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *BillMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case bill.FieldPayNumber:
		return m.AddedPayNumber()
	case bill.FieldPayTotal:
		return m.AddedPayTotal()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BillMutation) AddField(name string, value ent.Value) error {
	switch name {
	case bill.FieldPayNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPayNumber(v)
		return nil
	case bill.FieldPayTotal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPayTotal(v)
		return nil
	}
	return fmt.Errorf("unknown Bill numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *BillMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *BillMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *BillMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Bill nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *BillMutation) ResetField(name string) error {
	switch name {
	case bill.FieldPayNumber:
		m.ResetPayNumber()
		return nil
	case bill.FieldPayTotal:
		m.ResetPayTotal()
		return nil
	case bill.FieldPayTime:
		m.ResetPayTime()
		return nil
	}
	return fmt.Errorf("unknown Bill field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *BillMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.bank != nil {
		edges = append(edges, bill.EdgeBank)
	}
	if m.confirmation != nil {
		edges = append(edges, bill.EdgeConfirmation)
	}
	if m.owner != nil {
		edges = append(edges, bill.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *BillMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case bill.EdgeBank:
		if id := m.bank; id != nil {
			return []ent.Value{*id}
		}
	case bill.EdgeConfirmation:
		if id := m.confirmation; id != nil {
			return []ent.Value{*id}
		}
	case bill.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *BillMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *BillMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *BillMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedbank {
		edges = append(edges, bill.EdgeBank)
	}
	if m.clearedconfirmation {
		edges = append(edges, bill.EdgeConfirmation)
	}
	if m.clearedowner {
		edges = append(edges, bill.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *BillMutation) EdgeCleared(name string) bool {
	switch name {
	case bill.EdgeBank:
		return m.clearedbank
	case bill.EdgeConfirmation:
		return m.clearedconfirmation
	case bill.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *BillMutation) ClearEdge(name string) error {
	switch name {
	case bill.EdgeBank:
		m.ClearBank()
		return nil
	case bill.EdgeConfirmation:
		m.ClearConfirmation()
		return nil
	case bill.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Bill unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *BillMutation) ResetEdge(name string) error {
	switch name {
	case bill.EdgeBank:
		m.ResetBank()
		return nil
	case bill.EdgeConfirmation:
		m.ResetConfirmation()
		return nil
	case bill.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Bill edge %s", name)
}

// ConfirmationMutation represents an operation that mutate the Confirmations
// nodes in the graph.
type ConfirmationMutation struct {
	config
	op            Op
	typ           string
	id            *int
	adddate       *time.Time
	bookingstart  *time.Time
	bookingend    *time.Time
	hourstime     *int
	addhourstime  *int
	clearedFields map[string]struct{}
	owner         *int
	clearedowner  bool
	bill          map[int]struct{}
	removedbill   map[int]struct{}
	done          bool
	oldValue      func(context.Context) (*Confirmation, error)
}

var _ ent.Mutation = (*ConfirmationMutation)(nil)

// confirmationOption allows to manage the mutation configuration using functional options.
type confirmationOption func(*ConfirmationMutation)

// newConfirmationMutation creates new mutation for $n.Name.
func newConfirmationMutation(c config, op Op, opts ...confirmationOption) *ConfirmationMutation {
	m := &ConfirmationMutation{
		config:        c,
		op:            op,
		typ:           TypeConfirmation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConfirmationID sets the id field of the mutation.
func withConfirmationID(id int) confirmationOption {
	return func(m *ConfirmationMutation) {
		var (
			err   error
			once  sync.Once
			value *Confirmation
		)
		m.oldValue = func(ctx context.Context) (*Confirmation, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Confirmation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConfirmation sets the old Confirmation of the mutation.
func withConfirmation(node *Confirmation) confirmationOption {
	return func(m *ConfirmationMutation) {
		m.oldValue = func(context.Context) (*Confirmation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConfirmationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConfirmationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ConfirmationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetAdddate sets the adddate field.
func (m *ConfirmationMutation) SetAdddate(t time.Time) {
	m.adddate = &t
}

// Adddate returns the adddate value in the mutation.
func (m *ConfirmationMutation) Adddate() (r time.Time, exists bool) {
	v := m.adddate
	if v == nil {
		return
	}
	return *v, true
}

// OldAdddate returns the old adddate value of the Confirmation.
// If the Confirmation object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ConfirmationMutation) OldAdddate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAdddate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAdddate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdddate: %w", err)
	}
	return oldValue.Adddate, nil
}

// ResetAdddate reset all changes of the "adddate" field.
func (m *ConfirmationMutation) ResetAdddate() {
	m.adddate = nil
}

// SetBookingstart sets the bookingstart field.
func (m *ConfirmationMutation) SetBookingstart(t time.Time) {
	m.bookingstart = &t
}

// Bookingstart returns the bookingstart value in the mutation.
func (m *ConfirmationMutation) Bookingstart() (r time.Time, exists bool) {
	v := m.bookingstart
	if v == nil {
		return
	}
	return *v, true
}

// OldBookingstart returns the old bookingstart value of the Confirmation.
// If the Confirmation object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ConfirmationMutation) OldBookingstart(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBookingstart is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBookingstart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBookingstart: %w", err)
	}
	return oldValue.Bookingstart, nil
}

// ResetBookingstart reset all changes of the "bookingstart" field.
func (m *ConfirmationMutation) ResetBookingstart() {
	m.bookingstart = nil
}

// SetBookingend sets the bookingend field.
func (m *ConfirmationMutation) SetBookingend(t time.Time) {
	m.bookingend = &t
}

// Bookingend returns the bookingend value in the mutation.
func (m *ConfirmationMutation) Bookingend() (r time.Time, exists bool) {
	v := m.bookingend
	if v == nil {
		return
	}
	return *v, true
}

// OldBookingend returns the old bookingend value of the Confirmation.
// If the Confirmation object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ConfirmationMutation) OldBookingend(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBookingend is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBookingend requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBookingend: %w", err)
	}
	return oldValue.Bookingend, nil
}

// ResetBookingend reset all changes of the "bookingend" field.
func (m *ConfirmationMutation) ResetBookingend() {
	m.bookingend = nil
}

// SetHourstime sets the hourstime field.
func (m *ConfirmationMutation) SetHourstime(i int) {
	m.hourstime = &i
	m.addhourstime = nil
}

// Hourstime returns the hourstime value in the mutation.
func (m *ConfirmationMutation) Hourstime() (r int, exists bool) {
	v := m.hourstime
	if v == nil {
		return
	}
	return *v, true
}

// OldHourstime returns the old hourstime value of the Confirmation.
// If the Confirmation object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ConfirmationMutation) OldHourstime(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHourstime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHourstime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHourstime: %w", err)
	}
	return oldValue.Hourstime, nil
}

// AddHourstime adds i to hourstime.
func (m *ConfirmationMutation) AddHourstime(i int) {
	if m.addhourstime != nil {
		*m.addhourstime += i
	} else {
		m.addhourstime = &i
	}
}

// AddedHourstime returns the value that was added to the hourstime field in this mutation.
func (m *ConfirmationMutation) AddedHourstime() (r int, exists bool) {
	v := m.addhourstime
	if v == nil {
		return
	}
	return *v, true
}

// ResetHourstime reset all changes of the "hourstime" field.
func (m *ConfirmationMutation) ResetHourstime() {
	m.hourstime = nil
	m.addhourstime = nil
}

// SetOwnerID sets the owner edge to User by id.
func (m *ConfirmationMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the owner edge to User.
func (m *ConfirmationMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared returns if the edge owner was cleared.
func (m *ConfirmationMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the owner id in the mutation.
func (m *ConfirmationMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the owner ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *ConfirmationMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner reset all changes of the "owner" edge.
func (m *ConfirmationMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddBillIDs adds the bill edge to Bill by ids.
func (m *ConfirmationMutation) AddBillIDs(ids ...int) {
	if m.bill == nil {
		m.bill = make(map[int]struct{})
	}
	for i := range ids {
		m.bill[ids[i]] = struct{}{}
	}
}

// RemoveBillIDs removes the bill edge to Bill by ids.
func (m *ConfirmationMutation) RemoveBillIDs(ids ...int) {
	if m.removedbill == nil {
		m.removedbill = make(map[int]struct{})
	}
	for i := range ids {
		m.removedbill[ids[i]] = struct{}{}
	}
}

// RemovedBill returns the removed ids of bill.
func (m *ConfirmationMutation) RemovedBillIDs() (ids []int) {
	for id := range m.removedbill {
		ids = append(ids, id)
	}
	return
}

// BillIDs returns the bill ids in the mutation.
func (m *ConfirmationMutation) BillIDs() (ids []int) {
	for id := range m.bill {
		ids = append(ids, id)
	}
	return
}

// ResetBill reset all changes of the "bill" edge.
func (m *ConfirmationMutation) ResetBill() {
	m.bill = nil
	m.removedbill = nil
}

// Op returns the operation name.
func (m *ConfirmationMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Confirmation).
func (m *ConfirmationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ConfirmationMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.adddate != nil {
		fields = append(fields, confirmation.FieldAdddate)
	}
	if m.bookingstart != nil {
		fields = append(fields, confirmation.FieldBookingstart)
	}
	if m.bookingend != nil {
		fields = append(fields, confirmation.FieldBookingend)
	}
	if m.hourstime != nil {
		fields = append(fields, confirmation.FieldHourstime)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ConfirmationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case confirmation.FieldAdddate:
		return m.Adddate()
	case confirmation.FieldBookingstart:
		return m.Bookingstart()
	case confirmation.FieldBookingend:
		return m.Bookingend()
	case confirmation.FieldHourstime:
		return m.Hourstime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ConfirmationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case confirmation.FieldAdddate:
		return m.OldAdddate(ctx)
	case confirmation.FieldBookingstart:
		return m.OldBookingstart(ctx)
	case confirmation.FieldBookingend:
		return m.OldBookingend(ctx)
	case confirmation.FieldHourstime:
		return m.OldHourstime(ctx)
	}
	return nil, fmt.Errorf("unknown Confirmation field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ConfirmationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case confirmation.FieldAdddate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdddate(v)
		return nil
	case confirmation.FieldBookingstart:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBookingstart(v)
		return nil
	case confirmation.FieldBookingend:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBookingend(v)
		return nil
	case confirmation.FieldHourstime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHourstime(v)
		return nil
	}
	return fmt.Errorf("unknown Confirmation field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ConfirmationMutation) AddedFields() []string {
	var fields []string
	if m.addhourstime != nil {
		fields = append(fields, confirmation.FieldHourstime)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ConfirmationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case confirmation.FieldHourstime:
		return m.AddedHourstime()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ConfirmationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case confirmation.FieldHourstime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHourstime(v)
		return nil
	}
	return fmt.Errorf("unknown Confirmation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ConfirmationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ConfirmationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConfirmationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Confirmation nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ConfirmationMutation) ResetField(name string) error {
	switch name {
	case confirmation.FieldAdddate:
		m.ResetAdddate()
		return nil
	case confirmation.FieldBookingstart:
		m.ResetBookingstart()
		return nil
	case confirmation.FieldBookingend:
		m.ResetBookingend()
		return nil
	case confirmation.FieldHourstime:
		m.ResetHourstime()
		return nil
	}
	return fmt.Errorf("unknown Confirmation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ConfirmationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.owner != nil {
		edges = append(edges, confirmation.EdgeOwner)
	}
	if m.bill != nil {
		edges = append(edges, confirmation.EdgeBill)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ConfirmationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case confirmation.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case confirmation.EdgeBill:
		ids := make([]ent.Value, 0, len(m.bill))
		for id := range m.bill {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ConfirmationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedbill != nil {
		edges = append(edges, confirmation.EdgeBill)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ConfirmationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case confirmation.EdgeBill:
		ids := make([]ent.Value, 0, len(m.removedbill))
		for id := range m.removedbill {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ConfirmationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedowner {
		edges = append(edges, confirmation.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ConfirmationMutation) EdgeCleared(name string) bool {
	switch name {
	case confirmation.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ConfirmationMutation) ClearEdge(name string) error {
	switch name {
	case confirmation.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Confirmation unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ConfirmationMutation) ResetEdge(name string) error {
	switch name {
	case confirmation.EdgeOwner:
		m.ResetOwner()
		return nil
	case confirmation.EdgeBill:
		m.ResetBill()
		return nil
	}
	return fmt.Errorf("unknown Confirmation edge %s", name)
}

// UserMutation represents an operation that mutate the Users
// nodes in the graph.
type UserMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	age                 *int
	addage              *int
	name                *string
	email               *string
	password            *string
	birth               *time.Time
	tel                 *int
	addtel              *int
	clearedFields       map[string]struct{}
	confirmation        map[int]struct{}
	removedconfirmation map[int]struct{}
	bill                map[int]struct{}
	removedbill         map[int]struct{}
	done                bool
	oldValue            func(context.Context) (*User, error)
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows to manage the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for $n.Name.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the id field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetAge sets the age field.
func (m *UserMutation) SetAge(i int) {
	m.age = &i
	m.addage = nil
}

// Age returns the age value in the mutation.
func (m *UserMutation) Age() (r int, exists bool) {
	v := m.age
	if v == nil {
		return
	}
	return *v, true
}

// OldAge returns the old age value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldAge(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAge is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAge: %w", err)
	}
	return oldValue.Age, nil
}

// AddAge adds i to age.
func (m *UserMutation) AddAge(i int) {
	if m.addage != nil {
		*m.addage += i
	} else {
		m.addage = &i
	}
}

// AddedAge returns the value that was added to the age field in this mutation.
func (m *UserMutation) AddedAge() (r int, exists bool) {
	v := m.addage
	if v == nil {
		return
	}
	return *v, true
}

// ResetAge reset all changes of the "age" field.
func (m *UserMutation) ResetAge() {
	m.age = nil
	m.addage = nil
}

// SetName sets the name field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetEmail sets the email field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the email value in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old email value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail reset all changes of the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPassword sets the password field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the password value in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old password value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPassword is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword reset all changes of the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetBirth sets the birth field.
func (m *UserMutation) SetBirth(t time.Time) {
	m.birth = &t
}

// Birth returns the birth value in the mutation.
func (m *UserMutation) Birth() (r time.Time, exists bool) {
	v := m.birth
	if v == nil {
		return
	}
	return *v, true
}

// OldBirth returns the old birth value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldBirth(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBirth is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBirth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirth: %w", err)
	}
	return oldValue.Birth, nil
}

// ResetBirth reset all changes of the "birth" field.
func (m *UserMutation) ResetBirth() {
	m.birth = nil
}

// SetTel sets the tel field.
func (m *UserMutation) SetTel(i int) {
	m.tel = &i
	m.addtel = nil
}

// Tel returns the tel value in the mutation.
func (m *UserMutation) Tel() (r int, exists bool) {
	v := m.tel
	if v == nil {
		return
	}
	return *v, true
}

// OldTel returns the old tel value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldTel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTel is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTel: %w", err)
	}
	return oldValue.Tel, nil
}

// AddTel adds i to tel.
func (m *UserMutation) AddTel(i int) {
	if m.addtel != nil {
		*m.addtel += i
	} else {
		m.addtel = &i
	}
}

// AddedTel returns the value that was added to the tel field in this mutation.
func (m *UserMutation) AddedTel() (r int, exists bool) {
	v := m.addtel
	if v == nil {
		return
	}
	return *v, true
}

// ResetTel reset all changes of the "tel" field.
func (m *UserMutation) ResetTel() {
	m.tel = nil
	m.addtel = nil
}

// AddConfirmationIDs adds the confirmation edge to Confirmation by ids.
func (m *UserMutation) AddConfirmationIDs(ids ...int) {
	if m.confirmation == nil {
		m.confirmation = make(map[int]struct{})
	}
	for i := range ids {
		m.confirmation[ids[i]] = struct{}{}
	}
}

// RemoveConfirmationIDs removes the confirmation edge to Confirmation by ids.
func (m *UserMutation) RemoveConfirmationIDs(ids ...int) {
	if m.removedconfirmation == nil {
		m.removedconfirmation = make(map[int]struct{})
	}
	for i := range ids {
		m.removedconfirmation[ids[i]] = struct{}{}
	}
}

// RemovedConfirmation returns the removed ids of confirmation.
func (m *UserMutation) RemovedConfirmationIDs() (ids []int) {
	for id := range m.removedconfirmation {
		ids = append(ids, id)
	}
	return
}

// ConfirmationIDs returns the confirmation ids in the mutation.
func (m *UserMutation) ConfirmationIDs() (ids []int) {
	for id := range m.confirmation {
		ids = append(ids, id)
	}
	return
}

// ResetConfirmation reset all changes of the "confirmation" edge.
func (m *UserMutation) ResetConfirmation() {
	m.confirmation = nil
	m.removedconfirmation = nil
}

// AddBillIDs adds the bill edge to Bill by ids.
func (m *UserMutation) AddBillIDs(ids ...int) {
	if m.bill == nil {
		m.bill = make(map[int]struct{})
	}
	for i := range ids {
		m.bill[ids[i]] = struct{}{}
	}
}

// RemoveBillIDs removes the bill edge to Bill by ids.
func (m *UserMutation) RemoveBillIDs(ids ...int) {
	if m.removedbill == nil {
		m.removedbill = make(map[int]struct{})
	}
	for i := range ids {
		m.removedbill[ids[i]] = struct{}{}
	}
}

// RemovedBill returns the removed ids of bill.
func (m *UserMutation) RemovedBillIDs() (ids []int) {
	for id := range m.removedbill {
		ids = append(ids, id)
	}
	return
}

// BillIDs returns the bill ids in the mutation.
func (m *UserMutation) BillIDs() (ids []int) {
	for id := range m.bill {
		ids = append(ids, id)
	}
	return
}

// ResetBill reset all changes of the "bill" edge.
func (m *UserMutation) ResetBill() {
	m.bill = nil
	m.removedbill = nil
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.age != nil {
		fields = append(fields, user.FieldAge)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.birth != nil {
		fields = append(fields, user.FieldBirth)
	}
	if m.tel != nil {
		fields = append(fields, user.FieldTel)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldAge:
		return m.Age()
	case user.FieldName:
		return m.Name()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPassword:
		return m.Password()
	case user.FieldBirth:
		return m.Birth()
	case user.FieldTel:
		return m.Tel()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldAge:
		return m.OldAge(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldBirth:
		return m.OldBirth(ctx)
	case user.FieldTel:
		return m.OldTel(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAge(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldBirth:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirth(v)
		return nil
	case user.FieldTel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTel(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addage != nil {
		fields = append(fields, user.FieldAge)
	}
	if m.addtel != nil {
		fields = append(fields, user.FieldTel)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldAge:
		return m.AddedAge()
	case user.FieldTel:
		return m.AddedTel()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAge(v)
		return nil
	case user.FieldTel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTel(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldAge:
		m.ResetAge()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldBirth:
		m.ResetBirth()
		return nil
	case user.FieldTel:
		m.ResetTel()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.confirmation != nil {
		edges = append(edges, user.EdgeConfirmation)
	}
	if m.bill != nil {
		edges = append(edges, user.EdgeBill)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeConfirmation:
		ids := make([]ent.Value, 0, len(m.confirmation))
		for id := range m.confirmation {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeBill:
		ids := make([]ent.Value, 0, len(m.bill))
		for id := range m.bill {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedconfirmation != nil {
		edges = append(edges, user.EdgeConfirmation)
	}
	if m.removedbill != nil {
		edges = append(edges, user.EdgeBill)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeConfirmation:
		ids := make([]ent.Value, 0, len(m.removedconfirmation))
		for id := range m.removedconfirmation {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeBill:
		ids := make([]ent.Value, 0, len(m.removedbill))
		for id := range m.removedbill {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeConfirmation:
		m.ResetConfirmation()
		return nil
	case user.EdgeBill:
		m.ResetBill()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
